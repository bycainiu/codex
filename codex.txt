import undetected_chromedriver as uc
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import random
import string
import os
import re
from urllib.parse import urlparse, parse_qs
import secrets
import hashlib
import urllib3
import base64
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

TOTAL_ACCOUNTS = 4
# DuckMail ä¸´æ—¶é‚®ç®±é…ç½®
DUCKMAIL_API_URL = ""
DUCKMAIL_API_KEY = ""
DUCKMAIL_DOMAIN = ""  # ç§æœ‰åŸŸå

# OpenAI OAuth é…ç½®
OAUTH_ISSUER = "https://auth.openai.com"
OAUTH_CLIENT_ID = "app_EMoamEEZ73f0CkXaXp7hrann"
OAUTH_REDIRECT_URI = "http://localhost:1455/auth/callback"

# Output files
ACCOUNTS_FILE = "accounts.txt"
AK_FILE = "ak.txt"
RK_FILE = "rk.txt"

PROXY = ""


def extract_code_from_url(url: str):
    if not url:
        return None
    try:
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        code = params.get("code", [None])[0]
        return code
    except Exception as e:
        print(f"âŒ Failed to parse URL: {e}")
        return None


def generate_pkce():
    """ç”Ÿæˆ PKCE code_verifier å’Œ code_challenge"""
    code_verifier_bytes = secrets.token_bytes(64)
    code_verifier = base64.urlsafe_b64encode(code_verifier_bytes).rstrip(b'=').decode('ascii')

    digest = hashlib.sha256(code_verifier.encode('ascii')).digest()
    code_challenge = base64.urlsafe_b64encode(digest).rstrip(b'=').decode('ascii')
    
    return code_verifier, code_challenge


def generate_state():
    """ç”Ÿæˆéšæœº state å‚æ•°"""
    return base64.urlsafe_b64encode(secrets.token_bytes(32)).rstrip(b'=').decode('ascii')


def build_authorize_url(code_challenge, state):
    """æ„é€  OAuth æˆæƒ URL"""
    params = {
        "response_type": "code",
        "client_id": OAUTH_CLIENT_ID,
        "redirect_uri": OAUTH_REDIRECT_URI,
        "scope": "openid profile email offline_access",
        "code_challenge": code_challenge,
        "code_challenge_method": "S256",
        "state": state,
    }
    query = "&".join(f"{k}={requests.utils.quote(v)}" for k, v in params.items())
    return f"{OAUTH_ISSUER}/oauth/authorize?{query}"


def exchange_code_for_tokens(code, code_verifier):
    """ç”¨ authorization code æ¢å– tokens"""
    response = requests.post(
        f"{OAUTH_ISSUER}/oauth/token",
        headers={"Content-Type": "application/x-www-form-urlencoded"},
        data={
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": OAUTH_REDIRECT_URI,
            "client_id": OAUTH_CLIENT_ID,
            "code_verifier": code_verifier,
        },
        proxies={
            "http": PROXY,
            "https": PROXY,
        } if PROXY else {},
        verify=False,
        timeout=30
    )

    if response.status_code == 200:
        return response.json()  # {id_token, access_token, refresh_token}
    else:
        print(f"[-] Exchange code for tokens failed: {response.status_code} - {response.text}")
        return None


def wait_for_callback_url(driver, expected_state, timeout=60):
    print(f"Waiting for callback URL (max {timeout}s)...")
    """ç­‰å¾… OAuth callback URL"""
    start_time = time.time()
    while time.time() - start_time < timeout:
        current_url = driver.current_url
        print(f"Current URL: {current_url}")
        if "callback" in current_url and "code=" in current_url:
            # æ£€æŸ¥ state æ˜¯å¦åŒ¹é…
            parsed = urlparse(current_url)
            params = parse_qs(parsed.query)
            state = params.get("state", [None])[0]
            if state == expected_state:
                return current_url
        time.sleep(1)
    return None


def perform_openai_oauth_login(driver, email: str, password: str, jwt_token: str = None):
    """æ‰§è¡Œ OAuth ç™»å½•å¹¶è·å– tokensï¼ˆæ”¯æŒäºŒæ¬¡é‚®ç®±éªŒè¯ï¼‰"""
    code_verifier, code_challenge = generate_pkce()
    state = generate_state()
    auth_url = build_authorize_url(code_challenge, state)
    print(f"Auth URL: {auth_url}")

    print("\nğŸŒ Performing OpenAI OAuth login...")

    # åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€æˆæƒé“¾æ¥
    original_window = driver.current_window_handle
    driver.execute_script("window.open('', '_blank');")
    driver.switch_to.window(driver.window_handles[-1])
    driver.get(auth_url)
    time.sleep(3)

    try:
        print("ğŸ“§ Entering email for OAuth...")
        email_input = WebDriverWait(driver, 30).until(
            EC.visibility_of_element_located(
                (
                    By.CSS_SELECTOR,
                    'input[type="email"], input[name="email"], input[id="email"]',
                )
            )
        )
        email_input.clear()
        time.sleep(0.3)
        for char in email:
            email_input.send_keys(char)
            time.sleep(0.03)
        print(f"   Entered email: {email}")
        time.sleep(1)

        print("   Clicking Continue...")
        continue_btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
        )
        driver.execute_script("arguments[0].click();", continue_btn)
        time.sleep(3)
    except Exception as e:
        print(f"âš ï¸ Email input step error: {e}")

    try:
        print("ğŸ”‘ Entering password...")
        password_input = WebDriverWait(driver, 30).until(
            EC.visibility_of_element_located(
                (By.CSS_SELECTOR, 'input[type="password"], input[name="password"]')
            )
        )
        password_input.clear()
        time.sleep(0.3)
        for char in password:
            password_input.send_keys(char)
            time.sleep(0.03)
        print("   Entered password")
        time.sleep(1)

        print("   Clicking Continue...")
        continue_btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
        )
        driver.execute_script("arguments[0].click();", continue_btn)
        time.sleep(3)
    except Exception as e:
        print(f"âš ï¸ Password input step error: {e}")
        raise e

    # æ£€æµ‹æ˜¯å¦éœ€è¦äºŒæ¬¡é‚®ç®±éªŒè¯
    time.sleep(2)
    current_url = driver.current_url
    if "email-verification" in current_url and jwt_token:
        print("ğŸ” æ£€æµ‹åˆ°äºŒæ¬¡é‚®ç®±éªŒè¯ï¼Œæ­£åœ¨è·å–éªŒè¯ç ...")
        verification_code = wait_for_verification_email(email, jwt_token, timeout=60)
        if verification_code:
            print(f"   âœ… è·å–åˆ°éªŒè¯ç : {verification_code}")
            try:
                code_inputs = driver.find_elements(By.CSS_SELECTOR, 'input[type="text"], input[inputmode="numeric"]')
                if len(code_inputs) >= 6:
                    for i, digit in enumerate(verification_code[:6]):
                        code_inputs[i].send_keys(digit)
                        time.sleep(0.1)
                elif code_inputs:
                    code_inputs[0].clear()
                    code_inputs[0].send_keys(verification_code)
                print("   âœ… éªŒè¯ç å·²è¾“å…¥")
                time.sleep(2)
                try:
                    continue_btn = WebDriverWait(driver, 5).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
                    )
                    driver.execute_script("arguments[0].click();", continue_btn)
                    time.sleep(3)
                except:
                    pass
            except Exception as e:
                print(f"   âš ï¸ è¾“å…¥éªŒè¯ç å¤±è´¥: {e}")
        else:
            print("   âŒ æœªèƒ½è·å–éªŒè¯ç ")

    # å°è¯•ç‚¹å‡»å¯èƒ½å­˜åœ¨çš„ Continue æŒ‰é’®
    for _ in range(2):
        try:
            continue_btn = WebDriverWait(driver, 3).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
            )
            driver.execute_script("arguments[0].click();", continue_btn)
            time.sleep(2)
        except:
            break

    # ç­‰å¾… callback URL
    callback_url = wait_for_callback_url(driver, state)

    # å…³é—­æ ‡ç­¾é¡µ
    driver.close()
    driver.switch_to.window(original_window)

    if not callback_url:
        print("\nâ° Timeout waiting for callback")
        return None

    # æå– code å¹¶æ¢å– tokens
    parsed = urlparse(callback_url)
    params = parse_qs(parsed.query)
    code = params.get("code", [None])[0]

    if code:
        tokens = exchange_code_for_tokens(code, code_verifier)
        if tokens:
            print("âœ… Successfully obtained OAuth tokens")
            return tokens
    return None

def get_random_user_agent():
    return "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"

def generate_random_password(length=16):
    chars = string.ascii_letters + string.digits + "!@#$%"
    password = "".join(random.choice(chars) for _ in range(length))
    password = (
        random.choice(string.ascii_uppercase)
        + random.choice(string.ascii_lowercase)
        + random.choice(string.digits)
        + random.choice("!@#$%")
        + password[4:]
    )
    print(f"âœ… Generated password: {password}")
    return password



def create_temp_email():
    print("Creating temporary email via DuckMail...")

    try:
        # ç”Ÿæˆéšæœºé‚®ç®±åç§°
        letters1 = ''.join(random.choices(string.ascii_lowercase, k=random.randint(4, 6)))
        numbers = ''.join(random.choices(string.digits, k=random.randint(1, 3)))
        letters2 = ''.join(random.choices(string.ascii_lowercase, k=random.randint(0, 5)))
        random_name = letters1 + numbers + letters2
        email_address = f"{random_name}@{DUCKMAIL_DOMAIN}"
        email_password = ''.join(random.choices(string.ascii_letters + string.digits, k=16))

        # 1. åˆ›å»ºé‚®ç®±è´¦æˆ·
        res = requests.post(
            f"{DUCKMAIL_API_URL}/accounts",
            json={
                "address": email_address,
                "password": email_password,
            },
            headers={
                'Authorization': f'Bearer {DUCKMAIL_API_KEY}',
                "Content-Type": "application/json"
            },
            timeout=10,
            verify=False
        )
        if res.status_code != 201:
            print(f"[-] åˆ›å»ºé‚®ç®±æ¥å£è¿”å›é”™è¯¯: {res.status_code} - {res.text}")
            return None, None

        # 2. è·å–è®¤è¯ Token
        token_res = requests.post(
            f"{DUCKMAIL_API_URL}/token",
            json={
                "address": email_address,
                "password": email_password,
            },
            headers={"Content-Type": "application/json"},
            timeout=10,
            verify=False
        )
        if token_res.status_code == 200:
            token_data = token_res.json()
            jwt_token = token_data.get('token')
            print(f"âœ… Email created: {email_address}")
            return email_address, jwt_token
        else:
            print(f"[-] è·å–Tokenå¤±è´¥: {token_res.status_code} - {token_res.text}")
    except Exception as e:
        print(f"âŒ Email creation error: {e}")
    return None, None


def fetch_emails(email: str, jwt_token: str):
    try:
        res = requests.get(
            f"{DUCKMAIL_API_URL}/messages",
            headers={
                "Authorization": f"Bearer {jwt_token}",
                "Content-Type": "application/json"
            },
            verify=False,
        )

        if res.status_code == 200:
            data = res.json()
            members = data.get("hydra:member", [])
            if members:
                # è°ƒè¯•ï¼šæ‰“å°ç¬¬ä¸€å°é‚®ä»¶çš„å®Œæ•´ç»“æ„
                print(f"  ğŸ“¬ æ”¶åˆ° {len(members)} å°é‚®ä»¶")
                print(f"  ğŸ“‹ é‚®ä»¶ç»“æ„: {list(members[0].keys())}")
                return members
            return []
        else:
            print(f"  Fetch emails failed: HTTP {res.status_code}")
    except Exception as e:
        print(f"  Fetch emails error: {e}")
    return None


def extract_verification_code(email_content: str):
    if not email_content:
        return None
    patterns = [
        r"ä»£ç ä¸º\s*(\d{6})",
        r"code is\s*(\d{6})",
        r"(\d{6})",
    ]
    for pattern in patterns:
        matches = re.findall(pattern, email_content)
        if matches:
            code = matches[0]
            print(f"  âœ… Extracted code: {code}")
            return code
    return None


def wait_for_verification_email(email: str, jwt_token: str, timeout: int = 120):
    print(f"Waiting for verification email (max {timeout}s)...")
    start_time = time.time()
    while time.time() - start_time < timeout:
        emails = fetch_emails(email, jwt_token)
        if emails and len(emails) > 0:
            # æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åºï¼Œä¼˜å…ˆå¤„ç†æœ€æ–°é‚®ä»¶
            sorted_emails = sorted(emails, key=lambda x: x.get("createdAt", ""), reverse=True)
            for email_item in sorted_emails:
                if not isinstance(email_item, dict):
                    continue

                # DuckMail æ ¼å¼ï¼šfrom æ˜¯ dict å¯¹è±¡ {"address": "...", "name": "..."}
                from_field = email_item.get("from", {})
                if isinstance(from_field, dict):
                    sender = from_field.get("address", "").lower()
                elif isinstance(from_field, str):
                    sender = from_field.lower()
                else:
                    sender = ""

                subject = email_item.get("subject", "").lower()
                print(f"  ğŸ“§ é‚®ä»¶æ¥è‡ª: {sender}, ä¸»é¢˜: {subject[:30]}...")

                if "openai" in sender or "openai" in subject:
                    # ä¼˜å…ˆä»ä¸»é¢˜æå–éªŒè¯ç ï¼ˆæ ¼å¼ï¼šä½ çš„ chatgpt ä»£ç ä¸º XXXXXXï¼‰
                    subject_full = email_item.get("subject", "")
                    code = extract_verification_code(subject_full)
                    if code:
                        return code

                    # å¦‚æœä¸»é¢˜æ²¡æœ‰éªŒè¯ç ï¼Œå°è¯•ä»é‚®ä»¶æ­£æ–‡æå–
                    download_url = email_item.get("downloadUrl", "")
                    if download_url:
                        try:
                            # downloadUrl å¯èƒ½æ˜¯ç›¸å¯¹è·¯å¾„
                            if download_url.startswith("/"):
                                full_url = f"{DUCKMAIL_API_URL}{download_url}"
                            else:
                                full_url = download_url

                            res = requests.get(
                                full_url,
                                headers={"Authorization": f"Bearer {jwt_token}"},
                                verify=False
                            )
                            if res.status_code == 200:
                                raw_content = res.text
                                code = extract_verification_code(raw_content)
                                if code:
                                    return code
                        except Exception as e:
                            print(f"  è·å–é‚®ä»¶å†…å®¹å¤±è´¥: {e}")
                else:
                    print(f"  è·³è¿‡é OpenAI é‚®ä»¶")
                    continue
        elapsed = int(time.time() - start_time)
        print(f"  Waiting... ({elapsed}s)", end="\r")
        time.sleep(3)
    print("\nâ° Timeout waiting for email")
    return None


def save_account(email: str, password: str):
    """ä¿å­˜è´¦å·å¯†ç åˆ° accounts.txt"""
    with open(ACCOUNTS_FILE, "a", encoding="utf-8") as f:
        f.write(f"{email}:{password}\n")
    print(f"âœ… Account saved to {ACCOUNTS_FILE}")


def save_tokens(access_token: str, refresh_token: str = None):
    """ä¿å­˜ token åˆ°å¯¹åº”æ–‡ä»¶"""
    if access_token:
        with open(AK_FILE, "a", encoding="utf-8") as f:
            f.write(f"{access_token}\n")
        print(f"âœ… Access token saved to {AK_FILE}")
    if refresh_token:
        with open(RK_FILE, "a", encoding="utf-8") as f:
            f.write(f"{refresh_token}\n")
        print(f"âœ… Refresh token saved to {RK_FILE}")


def save_account_json(email: str, password: str, access_token: str, refresh_token: str = None, id_token: str = None):
    """ä¿å­˜è´¦å·ä¿¡æ¯åˆ°ç‹¬ç«‹ JSON æ–‡ä»¶ï¼Œæ ¼å¼ä¸¥æ ¼ä¸ codex-motto@2116666.xyz.json ä¸€è‡´"""
    import json
    from datetime import datetime, timedelta, timezone

    # è®¡ç®—æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ UTC+8ï¼‰
    tz = timezone(timedelta(hours=8))
    now = datetime.now(tz)
    expired = now + timedelta(days=10)  # access_token æœ‰æ•ˆæœŸçº¦10å¤©

    # ä» access_token ä¸­è§£æ account_idï¼ˆJWT payloadï¼‰
    account_id = ""
    try:
        import base64
        payload = access_token.split('.')[1]
        # è¡¥é½ base64 padding
        payload += '=' * (4 - len(payload) % 4)
        decoded = json.loads(base64.urlsafe_b64decode(payload))
        auth_info = decoded.get("https://api.openai.com/auth", {})
        account_id = auth_info.get("chatgpt_account_id", "")
    except:
        pass

    filename = f"codex-{email}.json"
    data = {
        "access_token": access_token,
        "account_id": account_id,
        "email": email,
        "expired": expired.strftime("%Y-%m-%dT%H:%M:%S+08:00"),
        "id_token": id_token or "",
        "last_refresh": now.strftime("%Y-%m-%dT%H:%M:%S+08:00"),
        "refresh_token": refresh_token or "",
        "type": "codex"
    }
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False)
    print(f"âœ… Account JSON saved to {filename}")


def check_and_handle_error(driver, max_retries=5):
    for attempt in range(max_retries):
        try:
            page_source = driver.page_source.lower()
            error_keywords = [
                "å‡ºé”™",
                "error",
                "timed out",
                "operation timeout",
                "route error",
                "invalid content",
            ]
            has_error = any(keyword in page_source for keyword in error_keywords)
            if has_error:
                try:
                    retry_btn = driver.find_element(
                        By.CSS_SELECTOR, 'button[data-dd-action-name="Try again"]'
                    )
                    print(
                        f"âš ï¸ Error page detected, clicking retry (attempt {attempt + 1}/{max_retries})..."
                    )
                    driver.execute_script("arguments[0].click();", retry_btn)
                    wait_time = 5 + (attempt * 2)
                    print(f"  Waiting {wait_time}s before continuing...")
                    time.sleep(wait_time)
                    return True
                except Exception:
                    time.sleep(2)
                    continue
            return False
        except Exception as e:
            print(f"  Error check exception: {e}")
            return False
    return False

def get_driver():
    options = uc.ChromeOptions()
    # é…ç½®Chromeä¸ºheadlessæ¨¡å¼ï¼Œåœ¨æ— å›¾å½¢ç•Œé¢ç¯å¢ƒä¸­è¿è¡Œ
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--disable-gpu')
    options.add_argument('--window-size=1920,1080')
    options.add_argument('--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
    if PROXY:
        options.add_argument(f'--proxy-server={PROXY}')
    print("Initializing undetected Chrome driver...")
    driver = uc.Chrome(options=options, driver_executable_path=ChromeDriverManager().install(), use_subprocess=True)
    return driver

def register_one_account(email: str = None, password: str = None):
    driver = get_driver()
    success = False

    try:
        if not email or not password:
            email, cf_token = create_temp_email()
            if not email:
                print("Failed to get email, aborting.")
                return None, None, False

            password = generate_random_password()
            url = "https://chat.openai.com/chat"
            print(f"Navigating to {url}...")
            driver.get(url)
            time.sleep(3)
            # screenshot the page
            driver.save_screenshot("page.png")
            print("Screenshot saved to page.png")
            wait = WebDriverWait(driver, 600)

            print("Waiting for signup button...")
            signup_button = wait.until(
                EC.element_to_be_clickable(
                    (By.CSS_SELECTOR, '[data-testid="signup-button"]')
                )
            )
            signup_button.click()
            print("Clicked signup button.")

            print("Waiting for email input...")
            email_input = WebDriverWait(driver, 120).until(
                EC.visibility_of_element_located((By.ID, "email"))
            )
            email_input.clear()
            email_input.send_keys(email)
            print(f"Entered email: {email}")

            print("Clicking Continue button...")
            continue_btn = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
            )
            continue_btn.click()
            print("Clicked Continue.")
            time.sleep(2)

            print("Waiting for password input...")
            password_input = WebDriverWait(driver, 120).until(
                EC.visibility_of_element_located(
                    (By.CSS_SELECTOR, 'input[autocomplete="new-password"]')
                )
            )
            password_input.clear()
            time.sleep(0.5)
            for char in password:
                password_input.send_keys(char)
                time.sleep(0.05)
            print(f"Entered password.")
            time.sleep(2)

            print("Clicking Continue button...")
            for attempt in range(3):
                try:
                    continue_btn = WebDriverWait(driver, 30).until(
                        EC.element_to_be_clickable(
                            (By.CSS_SELECTOR, 'button[type="submit"]')
                        )
                    )
                    driver.execute_script("arguments[0].click();", continue_btn)
                    print("Clicked Continue.")
                    break
                except Exception as e:
                    print(f"  Attempt {attempt + 1} failed, retrying...")
                    time.sleep(2)

            time.sleep(3)
            while check_and_handle_error(driver):
                time.sleep(2)

            time.sleep(5)
            verification_code = wait_for_verification_email(email, cf_token)

            if not verification_code:
                verification_code = input(
                    "Please enter the verification code manually: "
                ).strip()

            if not verification_code:
                print("âŒ No verification code, aborting.")
                return email, password, False

            print("Entering verification code...")
            while check_and_handle_error(driver):
                time.sleep(2)

            code_input = WebDriverWait(driver, 60).until(
                EC.visibility_of_element_located(
                    (
                        By.CSS_SELECTOR,
                        'input[name="code"], input[placeholder*="ä»£ç "], input[aria-label*="ä»£ç "]',
                    )
                )
            )
            code_input.clear()
            time.sleep(0.5)
            for char in verification_code:
                code_input.send_keys(char)
                time.sleep(0.1)
            print(f"Entered code: {verification_code}")
            time.sleep(2)

            print("Clicking Continue button...")
            for attempt in range(3):
                try:
                    continue_btn = WebDriverWait(driver, 30).until(
                        EC.element_to_be_clickable(
                            (By.CSS_SELECTOR, 'button[type="submit"]')
                        )
                    )
                    driver.execute_script("arguments[0].click();", continue_btn)
                    print("Clicked Continue.")
                    break
                except Exception as e:
                    print(f"  Attempt {attempt + 1} failed, retrying...")
                    time.sleep(2)

            time.sleep(3)
            while check_and_handle_error(driver):
                time.sleep(2)

            print("Waiting for name input...")
            # å°è¯•å¤šç§é€‰æ‹©å™¨
            name_selectors = [
                'input[name="name"]',
                'input[autocomplete="name"]',
                'input[autocomplete="given-name"]',
                'input[placeholder*="name" i]',
                'input[placeholder*="å§“å"]',
                'input[type="text"]'
            ]
            name_input = None
            for selector in name_selectors:
                try:
                    name_input = WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located((By.CSS_SELECTOR, selector))
                    )
                    print(f"  Found name input with: {selector}")
                    break
                except:
                    continue

            if not name_input:
                print("âš ï¸ Name input not found, trying to continue anyway...")
                # æˆªå›¾ä»¥ä¾¿è°ƒè¯•
                driver.save_screenshot("name_input_error.png")
            else:
                name_input.clear()
                time.sleep(0.5)
                for char in "John Doe":
                    name_input.send_keys(char)
                    time.sleep(0.05)
                print("Entered name: John Doe")
                time.sleep(1)

            print("Entering birthday...")
            time.sleep(1)

            # å°è¯•å¤šç§ç”Ÿæ—¥é€‰æ‹©å™¨
            birthday_found = False
            try:
                # æ–¹å¼1: data-type å±æ€§
                year_input = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, '[data-type="year"]'))
                )
                driver.execute_script(
                    "arguments[0].scrollIntoView({block: 'center'});", year_input
                )
                time.sleep(0.5)

                actions = ActionChains(driver)
                actions.click(year_input).perform()
                time.sleep(0.3)
                year_input.send_keys(Keys.CONTROL + "a")
                time.sleep(0.1)
                for char in "1990":
                    year_input.send_keys(char)
                    time.sleep(0.1)
                time.sleep(0.5)

                month_input = driver.find_element(By.CSS_SELECTOR, '[data-type="month"]')
                actions = ActionChains(driver)
                actions.click(month_input).perform()
                time.sleep(0.3)
                month_input.send_keys(Keys.CONTROL + "a")
                time.sleep(0.1)
                for char in "05":
                    month_input.send_keys(char)
                    time.sleep(0.1)
                time.sleep(0.5)

                day_input = driver.find_element(By.CSS_SELECTOR, '[data-type="day"]')
                actions = ActionChains(driver)
                actions.click(day_input).perform()
                time.sleep(0.3)
                day_input.send_keys(Keys.CONTROL + "a")
                time.sleep(0.1)
                for char in "12":
                    day_input.send_keys(char)
                    time.sleep(0.1)

                birthday_found = True
                print("Entered birthday: 1990/05/12")
            except Exception as e:
                print(f"  æ–¹å¼1å¤±è´¥: {e}")

            if not birthday_found:
                try:
                    # æ–¹å¼2: å°è¯• select ä¸‹æ‹‰æ¡†
                    selects = driver.find_elements(By.CSS_SELECTOR, 'select')
                    if len(selects) >= 3:
                        # å¹´æœˆæ—¥ä¸‹æ‹‰æ¡†
                        from selenium.webdriver.support.ui import Select
                        Select(selects[0]).select_by_value("1990")
                        Select(selects[1]).select_by_value("5")
                        Select(selects[2]).select_by_value("12")
                        birthday_found = True
                        print("Entered birthday via select: 1990/05/12")
                except Exception as e:
                    print(f"  æ–¹å¼2å¤±è´¥: {e}")

            if not birthday_found:
                print("âš ï¸ Birthday input not found, taking screenshot...")
                driver.save_screenshot("birthday_error.png")

            time.sleep(1)

            print("Entered birthday: 1990/05/12")
            time.sleep(1)

            print("Clicking final Continue button...")
            continue_btn = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]'))
            )
            continue_btn.click()
            print("Clicked Continue.")
        

        print("\nğŸ” Performing OAuth login to get access token...")
        while True:
            try:
                driver = get_driver()
                tokens = perform_openai_oauth_login(driver, email, password, cf_token)
                driver.quit()
                break
            except Exception as e:
                print(f"[-] OAuth login failed: {e}, retrying...")
                driver.quit()
                time.sleep(1)
                continue

        if tokens:
            access_token = tokens.get("access_token")
            refresh_token = tokens.get("refresh_token")
            id_token = tokens.get("id_token")

            save_account(email, password)
            save_tokens(access_token, refresh_token)
            save_account_json(email, password, access_token, refresh_token, id_token)

            print("\n" + "=" * 50)
            print("ğŸ‰ Registration & OAuth completed!")
            print(f"Email: {email}")
            print(f"Password: {password}")
            print(f"Access Token: {access_token[:20]}...")
            if refresh_token:
                print(f"Refresh Token: {refresh_token[:20]}...")
            print("=" * 50)

            success = True
        else:
            print("âŒ Failed to obtain OAuth tokens")
            save_account(email, password)  # ä¿å­˜è´¦å·å³ä½¿ OAuth å¤±è´¥

        print("Waiting before closing...")
        time.sleep(5)

    except Exception as e:
        print(f"An error occurred: {e}")
        if email and password:
            save_account(email, password)
    finally:
        print("Closing browser...")
        driver.quit()

    return email, password, success


def run_batch():
    print("\n" + "=" * 60)
    print(f"ğŸš€ Starting batch registration for {TOTAL_ACCOUNTS} accounts")
    print("=" * 60 + "\n")

    success_count = 0
    fail_count = 0
    registered_accounts = []

    for i in range(TOTAL_ACCOUNTS):
        print("\n" + "#" * 60)
        print(f"ğŸ“ Registering account {i + 1}/{TOTAL_ACCOUNTS}")
        print("#" * 60 + "\n")

        email, password, success = register_one_account()

        if success:
            success_count += 1
            registered_accounts.append((email, password))
        else:
            fail_count += 1

        print("\n" + "-" * 40)
        print(f"ğŸ“Š Progress: {i + 1}/{TOTAL_ACCOUNTS}")
        print(f"   âœ… Success: {success_count}")
        print(f"   âŒ Failed: {fail_count}")
        print("-" * 40)

        if i < TOTAL_ACCOUNTS - 1:
            wait_time = random.randint(5, 15)
            print(f"\nâ³ Waiting {wait_time}s before next registration...")
            time.sleep(wait_time)

    print("\n" + "=" * 60)
    print("ğŸ BATCH REGISTRATION COMPLETED")
    print("=" * 60)
    print(f"Total: {TOTAL_ACCOUNTS}")
    print(f"âœ… Success: {success_count}")
    print(f"âŒ Failed: {fail_count}")
    print("\nResults saved to:")
    print(f"  - {ACCOUNTS_FILE} (email:password)")
    print(f"  - {AK_FILE} (access tokens)")
    print(f"  - {RK_FILE} (refresh tokens)")
    print("=" * 60)


if __name__ == "__main__":
    run_batch()